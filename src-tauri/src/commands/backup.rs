//! Backup, restore, and export commands

use crate::backup::{ExportSummary, ImportPreview, ImportSummary};
use crate::AppState;
use tauri::State;
use tauri_plugin_dialog::DialogExt;

// ============================================================================
// Export Commands
// ============================================================================

/// Export format enum
#[derive(serde::Deserialize, Clone, Copy)]
pub enum ExportFormat {
    Markdown,
    PlainText,
    Html,
}

impl ExportFormat {
    fn extension(&self) -> &str {
        match self {
            Self::Markdown => "md",
            Self::PlainText => "txt",
            Self::Html => "html",
        }
    }

    fn filter_name(&self) -> &str {
        match self {
            Self::Markdown => "Markdown",
            Self::PlainText => "Plain Text",
            Self::Html => "HTML",
        }
    }

    fn format_content(&self, response_text: &str) -> String {
        match self {
            Self::Markdown => format!(
                "# Response\n\n{}\n\n---\n*Generated by AssistSupport*",
                response_text
            ),
            Self::PlainText => response_text.to_string(),
            Self::Html => {
                // Convert newlines to <br> and wrap in basic HTML
                let escaped = response_text
                    .replace('&', "&amp;")
                    .replace('<', "&lt;")
                    .replace('>', "&gt;")
                    .replace('\n', "<br>\n");
                format!(
                    "<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <title>Response</title>\n  <style>\n    body {{ font-family: system-ui, sans-serif; max-width: 800px; margin: 40px auto; padding: 20px; line-height: 1.6; }}\n  </style>\n</head>\n<body>\n  <h1>Response</h1>\n  <div>{}</div>\n  <hr>\n  <p><em>Generated by AssistSupport</em></p>\n</body>\n</html>",
                    escaped
                )
            }
        }
    }
}

/// Export a draft response to a file
#[tauri::command]
pub async fn export_draft(
    app: tauri::AppHandle,
    response_text: String,
    format: ExportFormat,
) -> Result<bool, String> {
    let content = format.format_content(&response_text);
    let default_filename = format!("response.{}", format.extension());

    // Build file dialog
    let file_handle = app
        .dialog()
        .file()
        .set_file_name(&default_filename)
        .add_filter(format.filter_name(), &[format.extension()])
        .blocking_save_file();

    match file_handle {
        Some(path) => {
            // Get the actual path
            let file_path = path
                .as_path()
                .ok_or_else(|| "Invalid file path".to_string())?;

            std::fs::write(file_path, content)
                .map_err(|e| format!("Failed to write file: {}", e))?;

            Ok(true)
        }
        None => {
            // User cancelled
            Ok(false)
        }
    }
}

// ============================================================================
// Backup/Restore Commands
// ============================================================================

/// Export all app data to a backup file (optionally encrypted with password)
#[tauri::command]
pub async fn export_backup(
    app: tauri::AppHandle,
    state: State<'_, AppState>,
    password: Option<String>,
) -> Result<ExportSummary, String> {
    let db_lock = state.db.lock().map_err(|e| e.to_string())?;
    let db = db_lock.as_ref().ok_or("Database not initialized")?;

    // Determine file extension based on encryption
    let (filename, filter_name, extensions) = if password.is_some() {
        ("assistsupport-backup.enc", "Encrypted Backup", &["enc"][..])
    } else {
        ("assistsupport-backup.zip", "ZIP Archive", &["zip"][..])
    };

    // Show save file dialog
    let file_handle = app
        .dialog()
        .file()
        .set_file_name(filename)
        .add_filter(filter_name, extensions)
        .blocking_save_file();

    match file_handle {
        Some(path) => {
            let file_path = path
                .as_path()
                .ok_or_else(|| "Invalid file path".to_string())?;

            crate::backup::export_backup(db, file_path, password.as_deref())
                .map_err(|e| e.to_string())
        }
        None => Err("Export cancelled".to_string()),
    }
}

/// Preview what will be imported from a backup file (with optional password for encrypted backups)
#[tauri::command]
pub async fn preview_backup_import(
    app: tauri::AppHandle,
    password: Option<String>,
) -> Result<ImportPreview, String> {
    // Show open file dialog (accept both ZIP and encrypted backups)
    let file_handle = app
        .dialog()
        .file()
        .add_filter("Backup Files", &["zip", "enc"])
        .add_filter("ZIP Archive", &["zip"])
        .add_filter("Encrypted Backup", &["enc"])
        .blocking_pick_file();

    match file_handle {
        Some(path) => {
            let file_path = path
                .as_path()
                .ok_or_else(|| "Invalid file path".to_string())?;

            crate::backup::preview_import(file_path, password.as_deref()).map_err(|e| e.to_string())
        }
        None => Err("Import cancelled".to_string()),
    }
}

/// Import data from a backup file (with optional password for encrypted backups)
#[tauri::command]
pub async fn import_backup(
    app: tauri::AppHandle,
    state: State<'_, AppState>,
    password: Option<String>,
) -> Result<ImportSummary, String> {
    let db_lock = state.db.lock().map_err(|e| e.to_string())?;
    let db = db_lock.as_ref().ok_or("Database not initialized")?;

    // Show open file dialog (accept both ZIP and encrypted backups)
    let file_handle = app
        .dialog()
        .file()
        .add_filter("Backup Files", &["zip", "enc"])
        .add_filter("ZIP Archive", &["zip"])
        .add_filter("Encrypted Backup", &["enc"])
        .blocking_pick_file();

    match file_handle {
        Some(path) => {
            let file_path = path
                .as_path()
                .ok_or_else(|| "Invalid file path".to_string())?;

            crate::backup::import_backup(db, file_path, password.as_deref())
                .map_err(|e| e.to_string())
        }
        None => Err("Import cancelled".to_string()),
    }
}
